layout: postcd ..
title: 端到端的数据
date: 2016-4-28 13:32:08
tags: 计算机网络
category:
- 网络
---
从网络的观点看，应用程序间彼此发送信息。每个消息只是一个未解释的字符串。然而，从应用程序的观点看，这些消息包含各种类型的数据——整型数组，视频帧，文本行，数字图像等。因此，我们需要考虑如何更好地对应用程序要转换成字符串的各种不同类型数据进行编码。

编码实质上涉及两个问题。第一是接收方能从信号中提取出于传送方发送的消息相同的消息，这就是组帧的问题。第二是尽可能地提高编码效率。
<!-- more -->
第一个问题，在发送方和接收方看到同样的数据时，就出现了发送方和接收方要统一消息格式的问题，通常称为表示格式(`presentation format`)。
第二个问题，提高编码效率。实际上，人们朝着两个相反的方向努力，一方面，我们希望在数据中加入尽可能多的冗余，以便即使消息出现了错误，接收方仍然能够提取出正确的数据。另一方面，我们希望尽可能从数据中删掉更多的冗余，以便能用更少的位去编码。这就是数据压缩的目的(`data compression`)

## 表示格式化
因为计算机用不同的方法表示数据，使得编码问题复杂。另外，不同应用程序使用不同的语言编码，而且即使使用同一种编程语言，也可能有不止一个编译程序，因此数据格式不统一。

### 分类方法

#### 数据类型
第一个问题是系统打算支持什么样的数据类型。通常，我们可以将由参数排列机制支持的类型分为三级。每一级都使参数排列系统面对更复杂的任务。

在最低一级，参数排列系统对基本类型(`base type`)的某个集合进行操作。通常，基本类型包括证书，浮点数和字符。系统还可以支持序数类型和布尔型。如上所述，基本类型集合的含义是指，编码进程必须能将每一基本类型从一种表示法转换为另一种表示法，如，把整形从大字节序转换为小字节序表示。

再上一级是扁平类型(`flat type`):结构和数组。为了按字的边界对齐字段，编译程序在编译应用程序时习惯于在组成结构的字段之间加入填充。参数排列系统通常将结构压缩使得他们不含填充。

在最高一级，参数排列系统必须处理复杂类型(`complex type`)：使用指针建立的类型。也就是说，一个程序要发送给另一个程序的数据结构可以不包括在某个单一的结构中，而可能包含从一个结构指向另一结构的指针。树就是包含指针的复杂类型的一个很好的例子。显然，数据编码器必须为网上传输准备好数据结构，因为指针是通过内存寻址实现的，而且驻留在一台机器上某个内存地址的结构并不意味着在另一机器上有相同的驻留地址。换句话说，参数排列系统必须串行化(`serialize`)复杂数据结构。

#### 转换策略
一般有两个选择：标准中间形式和接收方调整。

标准中间形式的概念就是要确定每一种类型的所有外部表示法；在发送数据前，发送主机将数据由其内部表示转换成这种数据的外部表示，而在接收数据的过程中，接收主机又把这种数据的外部表示转换成本地表示。

接收方调整允许发送方用其内部格式传输数据；发送方不进行基本类型的转换，但通常要压缩和展开较复杂的数据结构。然后接收方负责把数据从发送方的格式翻译成其本地的格式。用这种策略的问题是，每个主机必须准备好转换来自所有其他机器体系结构的数据。

#### 标记
参数排列中的第三个问题是接收方如何知道它接收的消息中包含什么类型的数据。有两种常用的方法：带标记(`tagged`)数据和不带标记(`untagged`)数据。

标记是指包含在一个消息中的任何附加消息，它有助于接收方解码消息。如类型标记，长度标记，体系结构标记。
不带标记，则需要在应用程序中指定数据信息。

#### 桩 stub
桩是实现参数排列的一段代码。在客户端，桩把过程参数排列成可以通过网络协议传输的消息。在服务器端，桩反过来把消息转换成一组用来调用远程过程的参数。
#### 例子 XDR,ASN.1,NDR
**XDR**
外部数据表示法(`External Data Representation`)是用在SunRPC上的网络格式。

**ASN.1**
抽象语法表示法1(`Abstract Syntax Notation One`)是一个ISO标准，他定义网上发送数据的一种表示方法。ASN.1用三元组形式表示每个数据项：`<tag,length,value>`

**NDR**
网络数据表示法(`Network Data Representation`)是用于分布式计算环境的数据编码标准。NDR使用的是接收方调整方式。NDR会在每个消息前插入一个体系结构标记，而对单个数据项是不带标记的。

## 数据压缩
压缩算法有两类。

一类称为无损压缩(`lossless compression`)，保证从压缩/解压过程恢复的数据与原始数据完全相同。无损压缩算法常用于压缩文件数据，比如可执行代码，文本文件和数值数据，因为处理这种文件数据的程序不允许数据有错。

相反，有损压缩(`lossy compression`)不能保证接收到的数据与发送的数据完全相同。这是因为，有损压缩算法会删除以后不能恢复的信息。有损压缩常用于压缩静止图像，视频和音频数据。
### 无损压缩算法
#### 行程编码 RLE
行程编码(`Run Length Encoding`)是一种极具简单性的压缩技术。其思想是，对连续出现的一个符号，只用此符号的一个副本加上符号出现的次数来替代；所以起名为“行程”。例如AAABBCDDDD串就被编码为3A2B1C4D。

#### 差分脉码调制 DPCM
首先输出一个参考符号，然后输出数据中的每个符号与参考符号的差。例如，使用符号A作为参考符号，字符串AAABBCDDDD将编码为A0001123333，因为A和参考符号相同，B和参考符号的差为1，依次类推。当差较小时，可以用比符号本身更少的比特去编码，在这个例子中，差的范围是0~3，每个符号可以用两个比特来表示，而用完全字符，就需要用7或8个比特。
另外一种略有差别的方法称为delta编码(`delta encoding`)，简单地把一个符号编码为与前一个符号的差。比如，AAABBCDDDD将被表示为A001011000，delta编码后还可以再进行RLE(行程编码)。

#### 基于字典的方法
基于字典的压缩算法，其思想是为你希望在数据中查找的可变长字符串(把他们看做常用短语)建立一个字典，当这些串出现在数据中时，用相应的字典索引去替代每个串。例如，"compression"一词在特定的词典中的索引为4978；因为在/usr/share/dict/words文件中它是第4978个词。要压缩一个文本的正文，每次当这个串出现时，就会用4978来代替。由于在这个特定的字典中只有25000多个词，需要用15个比特来编码这个索引，意味着串"compression"可以用15个比特而不是按字符串编码为77个比特来表示。

### 图像压缩(JPEG)
联合图像专家组(`Joint Photographic Expert Group`)压缩在三个阶段完成。
在压缩端，以每次一个8 * 8数据块让图像经过这是哪个阶段。第一个阶段是对这个数据块进行离散余弦变换(`Discrete Cosine Transform`)。第二个阶段将产生的信号进行量化，并且在量化过程中丢失信号所包含的最低有效信息。第三阶段编码出最终的结果，但在编码过程中，为前两个阶段完成的有损压缩增添了一个无损压缩的成分。

### 视频压缩(MPEG)
运动图像专家组(`Moving Picture Experts Group`)。粗略的说，运动图像(即视频)是简单地以某个视频速度连续显示的静止图像(也称为帧或图片)。

**帧类型**
MPEG接收一个视频帧序列作为输入，然后将其压缩成3种类型的帧，分别称为I帧(内部图像)，P帧(预测图像)和B帧(双向预测图像)。每个输入的帧被压缩成这3种类型之一。I帧可以作为参考帧，它们是独立的，即不依赖前面的帧也不依赖后面的帧。粗略的说，I帧是视频源对应帧的JPEG压缩形式。P帧和B帧不是独立的；它们定义相对某个参考帧的差。更明确的说，P帧说明与前一个I帧的差，而B帧给出前一个I帧或P帧与后一个I帧或P帧之间的插值。

### 音频压缩(MP3)
MP3使用MPEG压缩视频所使用的类似的技术。首先，将音频流拆分为某些频率的子波段。其次，每个子波段被分成一系列的块。最后，像MPEG视频一样，每个块用改进的DCT算法进行变化，量化和赫夫曼编码
