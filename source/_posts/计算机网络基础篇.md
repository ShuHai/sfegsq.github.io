layout: postcd ..
title: 计算机网络基础篇
date: 2016-4-22 13:26:29
tags: 计算机网络
category:
- 网络
---
# 基础 第一章
问题：建造一个网络
<!-- more -->

## 1.1 应用

`统一资源定位符（uniform resource locator,URL）`
点击一个URL后，因特网上可能需要交换多达17条消息才能得到网页，并且网页本身要小到可以存放在一条消息中。这些消息中有6条用来把服务器名翻译成他所对应的因特网地址（即IP地址，这个过程称为DNS解析），3条消息用来建立浏览器到服务器之间的传输控制协议（Transmission Control Protocol,TCP）的连接，4条消息用来让浏览器发送`HTTP`的`get`请求，并让服务器回送被请求的页面（以及双方对收到消息的确认），还有4条用来关闭TCP连接。

## 1.2 需求

### 1.2.1 连通

`交换网 switched network`
1. 电路交换 `circuit switched` (多用于电话系统)
2. 分组交换 `packet switched`  (多用于计算机网络)

**电路交换**  
首先通过一系列链路建立一条专用电路，然后允许源节点通过这条链路发送给比特流到目标节点。

**分组交换**  
分组交换网的主要特点是网络中的结点彼此间发送离散的数据块，我们称每个数据块为一个分组(packet)或一条消息(message)。分组交换网一般使用一种叫做存储转发(store-and-forward)的策略。

**路由选择**  
根据地址(mac或者ip)来确定如何将信息转发到目标节点的过程。

### 1.2.2 成本

1. 同步时分多路复用(synchronous time-division multiplexing,STDM)
2. 频分多路复用(frequency-division multiplexing,FDM)
3. 统计多路复用(statistical multiplexing)

**拥塞 `congested`**  
如果一段时间内，交换机接收分组的速度比它转送分组的速度快，那么交换机将最终用尽他的缓存空间，一些分组就会被丢弃。

### 1.2.3 支持公共服务

可靠性
1. 比特错(bit error)
2. 分组级别的错误，也就是网络丢失了整个分组
原因：分组含有不可纠正的比特错；拥塞丢失；处理分组的一个节点上运行的软件出现错误。
3. 节点和链路级
物理链路被切断或连接的计算机崩溃。

## 网络体系结构
1. OSI体系结构
2. 因特网体系结构

### 1.3.1 分层和协议
**抽象层**  
当系统变得复杂后，系统设计者引入另一个抽象层。抽象的思想是定义一个能捕获系统的主要特征的统一模型，并将这种模型封装为一个对象，为系统其它部分提供一个可操作的接口，对象如何实现的细节对于对象的使用者来说是隐藏的。

**网络分层结构**  
首先，它将建造一个网络的问题分解为多个可处理的部分，你不必希望实现所有的功能都集中在一个软件中，而是可以分几层，每一层解决一部分问题。第二，它提供一种更为模块化的设计，如果你想要加一些服务上去，只需要修改一层的功能，而继续使用其他各层提供的功能。

**协议(Protocol)**  
构成网络系统各层的抽象对象称为协议(Protocol)。每种协议定义两种不同的接口。首先，他为同一计算机上想使用它的通信服务的其他对象定义一个服务接口(service interface)。第二，一个协议为另一个机器上的对等实体定义一个对等接口(peer interface)。

**封装**  
原因：在硬件层，对等实体之间通过一条链路直接进行通信，除此之外，对等实体通信是间接的。每个协议和它的对等实体的通信是将消息传给更低层的协议，再由更低层协议将消息发给它的对等实体。  
方式：更低层的协议收到消息后，会将一个`首部(header)`附到消息上，有些协议则添加到消息的`尾部(tailer)`。格式由其协议规范定义，消息的奇遇部分称为`消息体(body)`或`有效载荷(payload)`

### 1.3.2 OSI体系结构
ISO制定的体系结构称为`开放系统互联(Open Systems Interconnection,OSI)体系结构`。

将网络按功能分为7层，其中由一个或多个协议实现分配给某个特定层的功能。
传输层和更高层通常只在终端主机上运行，不在中间交换机或路由器上运行。

1. 应用层 `application` 包括文件传输协议(FTP),它定义一个协议是的文件传输应用可以互操作
2. 表示层 `presentation` 关注对等实体间交换的数据的格式，例如一个整数是16，32还是64位，最先传输还是最后传输最高有效位，或者如何格式化一个视频流。
3. 会话层 `session` 提供一个名字空间用来将一个应用的各部分不同的传输流练习在一起。例如，在视频会议应用中，他可以同时管理一个音频流与一个视频流
4. 传输层 `transport `进程对进程的信道，在此交换的数据单元通常称为消息(message)
5. 网络层 `network` 处理分组交换网中节点的路由选择。在这一层，节点交换的数据单元通常称为分组(`packet`)而不是帧
6. 数据链路层 `data link`  收集比特流形成一个更大的集合体称为帧(frame)，典型情况下，由网络适配器和运行在节点操作系统上的设备驱动程序实现数据链路层。
7. 物理层 `physical` 处理通信链路上原始比特的传输

### 1.3.3 因特网体系结构
因特网体系结构，有时也成为TCP/IP体系结构，TCP和IP是它的两个主要协议。

1. 应用层 在传输层以上运行的应用协议，如FTP,普通文件传输协议(Trivial File Transport Protocol,TFTP),Telnet(远程登录)和简单邮件传输协议(Simple Mail Transfer Protocol,SMTP),使常用的应用可互操作。
2. TCP/UDP层 传输控制协议(`Transmission Control Protocol`)和用户数据报协议(User Datagram Protocol),TCP和UDP为应用程序提供可选的逻辑信道：TCP提供可靠的字节流信道，UDP提供不可靠的数据报传送信道(数据报可认为是消息的同义词)，在因特网语言中，TCP和UDP有时被称为端到端(end-to-end)的协议，还可以被认为是传输协议。
3. 网际协议层 `Internet Protocol` 这个协议支持多种网络技术互联为一个逻辑网络
4. 网络层 多种网络协议，表示为NET1,NET2等等，实际中，这些协议由硬件(如网络适配器)和软件(如网络设备驱动程序)共同实现。例如，以太网或光纤分布式数据接口(FDDI)协议。

因特网体系结构有3个特点，
第一，因特网体系结构并没有严格的划分层，这样应用比较自由，可以跨过层直接使用IP或一个底层网络，事实上，程序员可以自由定义新的信道抽象或在任何已有协议上运行的应用程序。
第二，IP作为体系结构的焦点，它定义各种网络中交换分组的一种共同方法。IP之上可以有多个传输协议，每个协议为应用程序提供一种不同的信道抽象。这样，从主机到主机传送消息的问题就完全从提供一种有用的进行到进程的通信服务的问题中分离了出来。IP之下，这个体系结构允许很多不同的网络技术，从以太网到FDDI，到ATM，到简单的点到点链路。
第三，为了在网络体系结构中提出一个官方新协议，必须产生一个协议规范和至少一个该规范的典型实现。


`沙漏`的设计理念，沙漏的细腰部代表最小的，经过精心挑选的通用功能集，他允许高层应用和低层通信技术并存，共享各种功能，并快速发展。
## 1.4 实现网络软件

每个协议提供一系列服务(service)，API则提供特定操作系统中调用这些服务所用的语法(syntax)。

### 1.4.1/1.4.2 应用编程接口(套接字) socket

### 1.4.3 协议实现的问题

#### 进程模型
大多数操作系统都提供一种称为进程(process)或线程(thread)的抽象概念。每个进程的运行很大程度上独立于其他进程，操作系统负责确保给所有当前进程分配如地址空间和CPU周期这样的资源。当操作系统停止正在CPU上执行的进程并启动另一进程时，我们成这一转换为上下文且含(context switch)。

**进程/协议(process-per-protocol)模型**
每个协议由一个独立的进程实现，这就意味着当一条消息向协议栈的上方或下方移动时，他被从一个进程/协议传送到另一个进程/协议。一个进程/协议如何向下一个进程/协议传递消息依赖于主机操作系统提供的进程间通信支持。通常有一个简单的机制用于进程的消息入队。然后，最重要的一点是，协议图的每一层都要求上下文切换，这是一个典型的耗费时间的操作。

**进程/消息(process-per-message)模型**
把每个协议当做一段静态编码并把进程同消息联系起来，也就是说，当一条消息从网络到达时，操作系统调度一个进程，使之负责消息在协议图中想上移动。在每一层调用实现协议的过程，由此导致调用实现下一个协议的过程，依此类推。

两个模型中，进程/消息模型更为高效，这是因为：在大多数计算机上，过程调用的效率比上下文切换高一个数量级。第一种模型要求每一层耗费一个上下文切换的代价，而第二种模型每一层只耗费一个进程调用。

#### 消息缓冲区

套接字第二个低效率在于当调用`send`操作时，应用程序进程提供缓冲区，该缓冲区保存向外发送的消息，类似于当调用receive操作时将进来的消息复制到缓冲区中。他强制最高层的协议把消息从应用程序缓冲区复制到网络缓冲区中，反之亦然。讲一个数据从一个缓存区复制到另一个缓存区是协议实现中开销最大的工作之一。这是因为处理器的速度飞速发展，而存储器的发展并不如处理器那么快。

为了不再协议栈的每一层都把消息从一个缓冲区复制到另一个缓存区中，大多数网络子系统定义了一种消息的抽象数据类型，它由协议图中的所有协议共享。这一抽象不仅允许消息不必复制就可以在协议图中向上或向下传递，而且它还提供其他无复制的方法来处理消息，如增加或去掉一个头部，将一个大的消息拆分成几个小的消息。消息抽象的确切格式随操作系统的不同而有所不同。

## 1.5 性能
### 1.5.1 带宽和时延
#### 带宽`bandwidth`(也成为吞吐量`throughput`)

网络的带宽是在一段特定时间内网络所能传送的比特数。

#### 时延`latency`(也成延迟`delay`)

将一个消息从网络的一段传到另一端所需花费的时间。在很多情况下，更重要的是知道一个消息从网络的一端传送到另一端并返回所花费的时间，而不只是单程的时延。我们称它为网络的往返时间(`round-trip time`)。

我们通常认为时延由三部分组成：第一，光速传播延迟；第二，发送一个数据单元花费的时间，它是网络带宽和运载数据分组的大小的函数；第三，网络内部的排队延迟，因为分组交换机在将分组转发出去之前通常需要将它存储一段时间。
计算公式
`latency = propagation + transmit + queue`
`propagation = distance/SpeedOfLight`
`transmit = size/bandwidth`

当消息只包括1比特且我们讨论一条链路而不是整个网络的情况时，那么`transmit`和`queue`就无关紧要了，时延只与传播延迟(`propagation delay`)有关。
### 1.5.2 延迟和带宽的乘积
延迟和带宽的乘积相当于第一个比特到达接受者之前，发送者必须发送的比特数。如果发送者希望接收者给出比特已开始到达的信号，而且这个信号发回到发送者需经另一个信道时延(即我们队信道的往返时延比单程时延更感兴趣)，那么发送者在接收到接收者发出的信号之前能够发完两倍时延和带宽乘积的数据。
